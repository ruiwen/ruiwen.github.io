<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.38" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  
  <title>Code and Random Hackery</title>
  

  
  <link rel="stylesheet" href="https://ruiwen.github.io/css/print.css" media="print">
  <link rel="stylesheet" href="https://ruiwen.github.io/css/poole.css">
  <link rel="stylesheet" href="https://ruiwen.github.io/css/syntax.css">
  <link rel="stylesheet" href="https://ruiwen.github.io/css/hyde.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://ruiwen.github.io/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="https://ruiwen.github.io/favicon.png">

  
  <link href="https://ruiwen.github.io/index.xml" rel="alternate" type="application/rss+xml" title="Code and Random Hackery" />

  
  
  
<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-3601512-3', 'auto');
ga('send', 'pageview');
</script>
<script async src='//www.google-analytics.com/analytics.js'></script>

  
</head>


<body class=" layout-reverse">

<div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="https://ruiwen.github.io/"><h1>Code and Random Hackery</h1></a>
      <p class="lead">
       An exploration 
      </p>
    </div>

    <ul class="sidebar-nav">
      <li><a href="https://ruiwen.github.io/">Home</a> </li>
      
        <li><a href="https://ruiwen.github.io/2016/10/30/kubernetes-for-small-organisations/"> Kubernetes for small Organisations </a></li>
      
        <li><a href="https://ruiwen.github.io/2016/10/03/ubuntu-16.04-on-raspberry-pi-3/"> Ubuntu 16.04 on Raspberry Pi 3 </a></li>
      
    </ul>

    <p>&copy; 2018. All rights reserved. </p>
  </div>
</div>


    <div class="content container">
<div class="posts">

      
  <div class="post">
    <h1 class="post-title">
      <a href="https://ruiwen.github.io/2018/05/29/a-single-repo-for-statically-generated-sites-on-github-pages/">
        A Single Repo for Statically Generated Sites on Github Pages
      </a>
    </h1>

    <span class="post-date">Tue, May 29, 2018</span>

    

<p>There&rsquo;s a lot of talk about how easy it is to setup a statically-generated blog (such as this!) using a static site generator and hosting it on Github pages.</p>

<p>In this post, we&rsquo;ll take a look at a simple <code>git</code> workflow that can be used to manage a statically-generated site, such as this.</p>

<p>Github pages usually publish the content from the <code>master</code> branch of a git repo, and while some tips found online might suggest keeping the generated content and the source material in separate repos, it&rsquo;s easier to have them all in one project that can be managed all at the same time.</p>

<p><em>For the rest of this post, we&rsquo;ll use the <a href="https://github.com/ruiwen/examplepage.github.io">examplepage repo</a> as an example. and assume we&rsquo;ll be using the <a href="https://gohugo.io">Hugo</a> blog generator.</em></p>

<h1 id="basic-setup">Basic Setup</h1>

<p>We&rsquo;ll first setup a new repo on Github to host the site. In this example, we&rsquo;re using <code>https://github.com/ruiwen/examplepage.github.io</code>.</p>

<p>We&rsquo;ll also need to ensure that we <a href="https://gohugo.io/getting-started/installing/">have Hugo installed</a>.</p>

<p>With that done, we can begin to setup our project directory. <code>hugo</code> provides a quick way to get started with that</p>

<pre><code>$ hugo new site -f yaml examplepage.github.io
Congratulations! Your new Hugo site is created in /home/ruiwen/projects/examplepage.github.io.

Just a few more steps and you're ready to go:

1. Download a theme into the same-named folder.
   Choose a theme from https://themes.gohugo.io/, or
   create your own with the &quot;hugo new theme &lt;THEMENAME&gt;&quot; command.
2. Perhaps you want to add some content. You can add single files
   with &quot;hugo new &lt;SECTIONNAME&gt;/&lt;FILENAME&gt;.&lt;FORMAT&gt;&quot;.
3. Start the built-in live server via &quot;hugo server&quot;.

Visit https://gohugo.io/ for quickstart guide and full documentation.


$ ls examplepage.github.io/
archetypes  config.yaml  content  data  layouts  static  themes
</code></pre>

<p><em>We use the <code>-f yaml</code> option to specify that we&rsquo;d like to use YAML as a configuration format. <code>hugo</code> defaults to TOML by default.</em></p>

<p>To get started, you&rsquo;ll need to <a href="https://gohugo.io/getting-started/configuration/">configure hugo</a>, setting values for the <code>baseURL</code>, and <code>title</code> of the site, but that&rsquo;s beyond the scope of this blog post.</p>

<p>For now, let&rsquo;s also create a simple blog post.</p>

<pre><code>$ hugo new post/a-sample-post.md
/home/ruiwen/projects/examplepage.github.io/content/post/a-sample-post.md created
</code></pre>

<p>You&rsquo;ll notice that new content is rooted at the <code>content/</code> directory, and all we need to do is to specify the path under that, eg. <code>post/a-sample-post.md</code>.</p>

<p>We&rsquo;ll also add some content to the new post.</p>

<pre><code>$ echo &quot;Here's a sample post! Welcome to our sample page!&quot; &gt;&gt; content/post/a-sample-post.md
$ cat content/posts/a-sample-post.md
---
title: &quot;A Sample Post&quot;
date: 2018-05-29T17:57:14+08:00
draft: true
---

Here's a sample post! Welcome to our sample page!
</code></pre>

<p>Before we publish the post, we&rsquo;ll need to <a href="https://gohugo.io/getting-started/quick-start/#step-3-add-a-theme">configure a theme</a> for the site. Check out <a href="https://themes.gohugo.io/">themes.gohugo.io</a> for themes. In our example, we&rsquo;re using <a href="https://themes.gohugo.io/hyde-hyde/"><code>hyde-hyde</code></a>.</p>

<pre><code>$ pwd
/home/ruiwen/projects/examplepage.github.io
$ git clone https://github.com/htr3n/hyde-hyde.git themes/hyde-hyde
Cloning into './hyde-hyde'...
remote: Counting objects: 597, done.
remote: Compressing objects: 100% (4/4), done.
remote: Total 597 (delta 0), reused 2 (delta 0), pack-reused 592
Receiving objects: 100% (597/597), 1.89 MiB | 809.00 KiB/s, done.
Resolving deltas: 100% (310/310), done.
Checking connectivity... done.
</code></pre>

<p>Next, edit <code>config.yaml</code> at the root of the project, and include <code>theme: hyde-hyde</code> at the bottom.</p>

<p>At this point, we&rsquo;re almost ready to publish the blog! We just need to remove the <code>draft: true</code> line in the post, and we&rsquo;re good to go.</p>

<p>To see what your site would look like, run the dev server, and navigate to <code>http://localhost:1313</code></p>

<pre><code>$ hugo server
</code></pre>

<h1 id="committing-to-git">Committing to <code>git</code></h1>

<p>Next up, we&rsquo;ll want to set up our git repo.</p>

<pre><code>$ git init
Initialized empty Git repository in /home/ruiwen/projects/examplepage.github.io/.git/
$ git remote add github https://github.com/ruiwen/examplepage.github.io
</code></pre>

<p>First, we want to create an initial empty commit. This will be our repo&rsquo;s starting point, and allow us to manage two different aspects of the site in the same repo.</p>

<pre><code>$ git commit --allow-empty -m &quot;Initial empty commit&quot;
[master (root-commit) d9c0248] Initial empty commit
</code></pre>

<p>We&rsquo;ll want to create a new branch, that is <em>not</em> <code>master</code>. For this example, we use <code>source</code></p>

<pre><code>$ git checkout -b source
Switched to a new branch 'source'
</code></pre>

<p>Then we add all the files</p>

<pre><code>$ git add .
$ git commit -m &quot;New post: A sample post&quot;
[source 2f14616] New post: A sample post
4 files changed, 21 insertions(+)
create mode 100644 archetypes/default.md
create mode 100644 config.yaml
create mode 100644 content/post/a-sample-post.md
create mode 160000 themes/hyde-hyde
$ git log --oneline --graph --decorate --all
* 2f14616 New post: A sample post  (HEAD -&gt; source) [Ruiwen Chua 1 second ago]
* d9c0248 Initial empty commit  (master) [Ruiwen Chua 60 seconds ago]
</code></pre>

<p>We see that the source files have been committed to the <code>source</code> branch.</p>

<p>Now, because Github pages deploys content from the <code>master</code> branch, we want a) the fully rendered static files to reside in the <code>master</code> branch, and b) none of the source files to reside in the <code>master</code> branch. Hugo renders to <code>public/</code> by default, so we&rsquo;ll want make sure that our <code>public/</code> directory represents our <code>master</code> branch.</p>

<h1 id="setting-public-as-our-master-branch">Setting <code>public/</code> as our <code>master</code> branch</h1>

<p>We&rsquo;ll first make <code>public/</code> the home of our <code>master</code> branch. <code>git</code> has a wonderful tool that allows us to checkout a branch into its own directory that resides right alongside the rest of the repo. We&rsquo;ll use <code>git worktree</code> to make this happen.</p>

<pre><code>$ git worktree add -b master public
Preparing public (identifier public)
HEAD is now at d9c0248 Initial empty commit
</code></pre>

<p>The interesting thing about <code>git worktree</code> is that it allows us to check out a completely different branch of the repo and have it checked out alongside any other branch we happen to be working on.</p>

<pre><code>$ cd public
$ ls
$ git branch
* master
  source
</code></pre>

<p>In the <code>public/</code> directory, we don&rsquo;t see any files in the listing, because the <code>master</code> branch is currently pointing at our original empty commit. However, we do see that <code>git</code> recognises that we are, in fact, in the <code>master</code> branch, and not the <code>source</code> branch, where we were previously.</p>

<p>Now that <code>public/</code> represents our <code>master</code> branch, we&rsquo;re going to get <code>hugo</code> to render our site into it.</p>

<pre><code>$ hugo
                   | EN
+------------------+----+
  Pages            |  7
  Paginator pages  |  0
  Non-page files   |  0
  Static files     |  8
  Processed images |  0
  Aliases          |  0
  Sitemaps         |  1
  Cleaned          |  0

Total in 239 ms
$ ls public/
404.html  apple-touch-icon-144-precomposed.png  categories  css  favicon.png  img  index.html  index.xml  sitemap.xml  tags
$ cd public
$ git status
On branch master
Untracked files:
  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)

        404.html
        apple-touch-icon-144-precomposed.png
        categories/
        css/
        favicon.png
        img/
        index.html
        index.xml
        sitemap.xml
        tags/

nothing added to commit but untracked files present (use &quot;git add&quot; to track)
</code></pre>

<p>We&rsquo;ll just commit the files in <code>public/</code>, and they should be added to our <code>master</code> branch</p>

<pre><code>$ git add .
$ git ci -m &quot;Publish: 20180529&quot;
[master ff17216] Publish: 20180529
 16 files changed, 1288 insertions(+)
 create mode 100644 404.html
 create mode 100644 apple-touch-icon-144-precomposed.png
 create mode 100644 categories/index.html
 create mode 100644 categories/index.xml
 create mode 100644 css/custom.css
 create mode 100644 css/hyde.css
 create mode 100644 css/poole.css
 create mode 100644 css/print.css
 create mode 100644 css/syntax.css
 create mode 100644 favicon.png
 create mode 100644 img/hugo.png
 create mode 100644 index.html
 create mode 100644 index.xml
 create mode 100644 sitemap.xml
 create mode 100644 tags/index.html
 create mode 100644 tags/index.xml
$ git lg
* ff17216 Publish: 20180529  (HEAD -&gt; master) [Ruiwen Chua 2 seconds ago]
| * 2f14616 New post: A sample post  (source) [Ruiwen Chua 54 seconds ago]
|/
* d9c0248 Initial empty commit  [Ruiwen Chua 2 minutes ago]
</code></pre>

<p>Now we see that the rendered site under <code>public/</code> has been committed to the <code>master</code> branch, while the source material still remain on the <code>source</code> branch. Both branches branch from the initial empty commit we made, and both branches can exist simultaneously in the same working environment, thanks to <code>git worktree</code>. This suits <code>hugo</code>&rsquo;s publishing workflow pretty well, allowing us to render straight into our <code>master</code> branch for committing.</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://ruiwen.github.io/2017/08/26/monitoring-of-a-kubernetes-cluster-from-the-outside-with-prometheus/">
        Monitoring of a Kubernetes Cluster from the Outside with Prometheus
      </a>
    </h1>

    <span class="post-date">Sat, Aug 26, 2017</span>

    

<p>When setting up a Kubernetes cluster, a <a href="https://prometheus.io">Prometheus</a> and <a href="https://grafana.com">Grafana</a> setup is a great way to have to start monitoring your cluster health. From CPU and RAM stats, to filesystem usage, to even the number and type of requests that your cluster is serving. One thing however, is that <a href="https://github.com/prometheus/prometheus/blob/v1.0.1/documentation/examples/prometheus-kubernetes.yml#L32-L34">most</a> setups tend to assume that you&rsquo;ll be deploying Prometheus within the cluster itself. To be sure, this is probably the easier way of settings things up. Within the cluster, your Prometheus set up will have no issues finding and monitoring the configured pods, endpoints and nodes.</p>

<h2 id="the-problem-with-an-out-cluster-prometheus-setup">The Problem with an out-cluster Prometheus setup</h2>

<p>That said, sometimes, it&rsquo;s not entirely feasible to deploy Prometheus within a particular cluster — for example, if you wanted Prometheus to monitor mulitple Kubernetes clusters across multiple service providers like AWS and Azure.</p>

<p>In this scenario, I&rsquo;ve found it more convenient to host Prometheus separately, outside the Kubernetes clusters, then set it up to monitor the clusters and their services and pods.</p>

<p>However, I ran into yet another problem, which was properly exposing the services to have them scaped by Prometheus — particularly in the case of Deployments that spanned more than one Pod. While I could potentially include sidecar containers in each Pod exposing <code>/metrics</code> on a given port, I struggled to find a way to properly expose them to an out-cluster Prometheus. I could expose an Ingress and have Prometheus access the endpoint through the cluster&rsquo;s main IP, but given as how Kubernetes Services deliver requests to their backing Pods in a round-robin fashion, this meant that <em>each successive scrape could end up hitting a different pod</em>. This would lead to confusing metrics to say the least. Ideally, what we would want is for Prometheus to be able to distinguish between the metrics scraped from each individual pod (with a different label for each pod), that way, we could tell if, say, one Pod ended up serving more traffic than the others in the Deployment.</p>

<p>One option to address each Pod individually would perhaps be to expose one Ingress per Pod. Of course, this would have to be automated in some form, perhaps having yet another Service watch new pods being spun up and creating the necessary exporters and Ingresses automatically, but this approach quickly gets very unwieldy, without even considering what happens once we start scaling in any form.</p>

<p>So now we have two problems. We want to</p>

<ul>
<li>have Prometheus be able to access the metrics endpoints for all necessary pods, without the need to have to define them beforehand,</li>
<li>and do so from outside the cluster,  without having to manually (or otherwise) open up Ingresses</li>
</ul>

<h2 id="abusing-the-api-server">Abusing the API Server</h2>

<p>As it turns out, the APIServer does in fact allow us to communicate directly with the Pods, without necessarily creating an Ingress, or a Service beforehand. All that&rsquo;s needed is the proper credentials and authorisation to make HTTP requests through the APIServer.</p>

<p>It&rsquo;s not terribly obvious from the outset, but even the very familiar <code>kubectl</code> does in fact communicate with the APIServer (and manages the cluster) via simple HTTP calls. (Run any <code>kubectl</code> command with the <code>-v 10</code> option to see the HTTP calls that are being made in the background — eg. <code>kubectl -v 10 version</code>)</p>

<h3 id="access-control">Access Control</h3>

<p>In order to communicate with the APIServer through its API though, we&rsquo;ll first need to set up some form of access control.</p>

<p>If you&rsquo;re on Kubernetes &lt; 1.6, you&rsquo;ll have to use <a href="https://kubernetes.io/docs/admin/authorization/abac/">Attributed-based Access Control (ABAC)</a>, and if you&rsquo;re running Kubernetes &gt; 1.6, you&rsquo;ll be able to use the more convenient <a href="https://kubernetes.io/docs/admin/authorization/rbac/">Role-based Access Control (RBAC)</a>. A discussion on how to effectively use ABAC vs RBAC is beyond the scope of this post, but essentially, you&rsquo;ll want to end up with an access token (eg. a ServiceAccount&rsquo;s Secret token value) that will allow you to make authenticated and authorised requests to the APIServer.</p>

<p><em>If you&rsquo;d just like to try it out, you could run <code>kubectl -v 10 version</code>, watch the HTTP calls, and simply use the values <code>kubectl</code> is sending in the <code>Authorization</code> HTTP header. For production setups however, I&rsquo;d recommend setting up a proper ServiceAccount with appropriately scoped permissions.</em></p>

<h3 id="accessing-pods-through-the-apiserver">Accessing Pods through the APIServer</h3>

<p>It&rsquo;s not commonly mentioned in the general Kubernetes documentation, but APIServer does allow you to make rquests directly to the pods within the cluster.</p>


<figure>
    
        <img src="https://ruiwen.github.io/img/kubernetes-api-get.png" alt="It&#39;s hardly clear what you&#39;re supposed to do with this, and the lack of documented examples don&#39;t help either" />
    
    
    <figcaption>
        <h4>Get Connect Proxy Path</h4>
        <p>
        It&#39;s hardly clear what you&#39;re supposed to do with this, and the lack of documented examples don&#39;t help either
        
            
        
        </p> 
    </figcaption>
    
</figure>


<p>However, with the handy documentation on this page, we can make HTTP calls <em>directly to each pod, through the Kubernetes API server</em>, without needing to create a specific Ingress for each Pod that we&rsquo;d like to have Prometheus scrape. It follows that this means that we can afford to then expose metrics pages only on cluster-local IP addresses, without worry of those pages leaking out to the public Internet.</p>

<p>From the Kubernetes API documentation, we can refer to the sections on Proxy operations for the various Kubernetes objects. For example, the <a href="https://v1-7.docs.kubernetes.io/docs/api-reference/v1.7/#get-proxy-path">Pod proxy operations</a> show us how to reach out to a specific Pod through the Kubernetes API.</p>

<p>Assuming we have a Prometheus exporter pod, <code>prom-exporter</code> in the namespace <code>monitoring</code>, that exposes metrics at the path <code>/metrics</code>, that we&rsquo;d like to scrape.</p>

<p>The general pattern of the request looks like</p>

<pre><code>GET /api/v1/proxy/namespaces/{namespace}/pods/{name}/{path}
</code></pre>

<p>We can make a request to the Pod via the call below</p>

<pre><code>GET /api/v1/proxy/namespaces/monitoring/pods/prom-exporter/metrics
#
# As a curl command, it should look something like
#
# $ curl &quot;https://&lt;api_server:port&gt;/api/v1/proxy/namespaces/monitoring/pods/prom-exporter/metrics
</code></pre>

<p>which should give us our exported metrics.</p>

<h3 id="security">Security</h3>

<p>Naturally, when you&rsquo;re setting up Prometheus to perform scraping through the proxy API in this manner, you&rsquo;ll want to be connecting over HTTPS to ensure that your metrics are not leaked to third parties over the wire. However though, since Kubernetes APIServer SSL certs are usually self signed, you&rsquo;ll also want to include your APIServer&rsquo;s CA certificate in your Prometheus configuration so that you can authenticate the server.</p>

<p>In your <code>prometheus.yml</code>,</p>

<pre><code class="language-yaml">    ...
    - job_name: 'natsd'
      scheme: https
      bearer_token: &quot;$KUBERNETES_TOKEN&quot;
      tls_config:
        ca_file: /etc/prometheus/tls/certs/kubernetes.crt

      kubernetes_sd_configs:
      - api_server: 'host.kubernetes.apiserver.com'
        bearer_token: &quot;$KUBERNETES_TOKEN&quot;
        tls_config:
          ca_file: /etc/prometheus/tls/certs/kubernetes.crt
        role: pod
    ...
</code></pre>

<p>Extracting the CA certificate from the APIServer is a matter of running (assuming the APIServer is running at <code>192.168.1.10</code>),</p>

<pre><code>$ openssl s_client -connect 192.168.1.10:6443 &lt; /dev/null | openssl x509 -text
&lt;... truncated ...&gt;
    Signature Algorithm: sha256WithRSAEncryption
     73:2b:6e:46:d7:16:10:e8:f3:31:ba:56:a7:3a:e7:23:b2:2a:
     78:27:4e:4d:0e:a8:de:46:29:e7:14:60:99:e2:50:00:d7:2b:
     de:87:e1:a5:25:3a:14:fa:6e:41:82:dc:4f:9c:5c:83:7e:4e:
     5d:94:46:4b:10:7a:19:83:4e:fc:4d:71:ee:38:51:e0:1f:61:
     57:64:54:34:42:77:bd:7b:eb:61:b7:de:e7:60:82:c1:e6:1f:
     b5:47:bd:94:a0:a1:cf:cd:fd:ac:b4:63:9c:55:16:a5:2f:d3:
     c9:63:dd:ba:c5:38:30:9d:62:0b:e8:d3:b8:38:ea:08:67:4d:
     f3:2e:57:d7:fc:74:7d:16:9d:5f:a9:9d:d8:71:5a:de:70:ed:
     ac:04:ad:92:03:ac:2d:0f:f6:a8:6f:63:56:77:5d:7b:5e:b3:
     d1:a1:b8:09:34:fe:12:23:18:50:a7:dd:85:2f:ae:00:49:e4:
     e9:6d:6d:9c:d1:52:e6:2f:16:89:6b:05:e7:46:8c:b0:b5:84:
     38:e1:8a:06:82:4c:8a:05:bf:e7:38:53:45:a3:73:bd:bc:67:
     05:c3:ec:4a:65:d1:c9:d1:08:a2:6d:11:e2:c2:81:78:81:16:
     0c:b6:57:4f:82:e6:02:77:4e:9a:e6:99:bc:ad:bd:08:2a:8d:
     c0:9d:40:3c
-----BEGIN CERTIFICATE-----
MIIDbzCCAlegAwIBAgIIF8beimuBxWAwDQYJKoZIhvcNAQELBQAwFTETMBEGA1UE
AxMKa3ViZXJuZXRlczAeFw0xNzEyMDQwNjEyMDNaFw0xODEyMDQwNjEyMDNaMBkx
FzAVBgNVBAMTDmt1YmUtYXBpc2VydmVyMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8A
MIIBCgKCAQEApovuAK4JmvuHqoV4FUHJveXZryKoqn/g8ej8DZYqRKDV8uAFnbIk
2OQcKR3nfeK4N5PihS8ecbSOiwJbWGUNCPj4WLmlFCOz1/s5Zt3vpIfSlX34eYR8
ubWCEuk+dsXKZOYn/ZZK+Ev/gpf9GA2HjTLz43FBJnyLd3o4reltsh+/qgDCFK0k
u3PoagHbCNWOLXGx8rIHHU3DOMf2r9pYagjHveSr42Fpa89OhpA91s/YsBuN3Ab8
cCHHM/Ui5IG6jxLkQ+vBqBWTPoGEQ82tK4e/e9XwJGKH2zcHwEJRVbGsipcL88eT
0NZjvFD3UoVhA27eV6lfPW3MGkn8RAnKsQIDAQABo4G+MIG7MA4GA1UdDwEB/wQE
AwIFoDATBgNVHSUEDDAKBggrBgEFBQcDATCBkwYDVR0RBIGLMIGIggprdWJlbWFz
dGVyggprdWJlcm5ldGVzghJrdWJlcm5ldGVzLmRlZmF1bHSCFmt1YmVybmV0ZXMu
ZGVmYXVsdC5zdmOCJGt1YmVybmV0ZXMuZGVmYXVsdC5zdmMuY2x1c3Rlci5sb2Nh
bIIKa3ViZY1hc3RlcocEwKgBCocECmAAAYcEwKgBCjANBgkqhkiG9w0BAQsFAAOC
AQEAcytuRtcWEOjzMbpWpzrnI7IqeCdOTQ6o3kYp5xRgmeJQANcr3ofhpSU6FPpu
QYLcT5xcg35OXZRGSxB6GYNO/E1x7jhR4B9hV2RUNEJ3vXvrYbfe52CCweYftUe9
lKChz839rLRjnFUWpS/TyWPdusU4MJ1iC+jTuDjqCGdN8y5X1/x0fRadX6md2HFa
3nDtrAStkgOsLQ/2qG9jVndde16z0aG4CTT+EiMYUKfdhS+uAEnk6W1tnNFS5i8W
iWsF50aMsLWEOOGKBoJMigW/5zhTRaNzvbxnBcPsSmXRydEIom0R4sKBeIEWDLZX
T4LmAndOiuaZvK29CCqNwJ1APA==
-----END CERTIFICATE-----
</code></pre>

<p>The important bit is between the <code>BEGIN CERTIFICATE</code> and <code>END CERTIFICATE</code> lines, inclusive. Save that to a file named <code>ca.crt</code> (for example), and include it in your <code>prometheus.yml</code>.</p>

<h3 id="putting-it-together">Putting it together</h3>

<p>Eventually, our configuration ends up looking something like this</p>

<pre><code class="language-yaml">    ...
    - job_name: 'natsd'
      scheme: https
      bearer_token: &quot;$KUBERNETES_TOKEN&quot;
      tls_config:
        ca_file: /etc/prometheus/tls/certs/kubernetes.crt

      kubernetes_sd_configs:
      - api_server: 'host.kubernetes.apiserver.com'
        bearer_token: &quot;$KUBERNETES_TOKEN&quot;
        tls_config:
          ca_file: /etc/prometheus/tls/certs/kubernetes.crt
        role: pod

      # Tells Prometheus to query the APIServer for all pods matching the target label (natsd-*) below
      # and for each of the pods, generate a scrape target at the `/metrics` path via the proxy API
      relabel_configs:
      - source_labels: [__meta_kubernetes_namespace, __meta_kubernetes_pod_name, __meta_kubernetes_pod_container_port_name]
        action: keep
        regex: default;natsd-.*;metrics  # Remember to use the right 'container_port_name` as specified in the Deployment
      - target_label: __address__
        replacement: 'host.kubernetes.apiserver.com'  # API server address
      - source_labels: [__meta_kubernetes_namespace, __meta_kubernetes_pod_name,__meta_kubernetes_pod_container_port_number]
        regex: (.+);(.+);(.+)
        target_label: __metrics_path__
        replacement: /api/v1/namespaces/${1}/pods/http:${2}:${3}/proxy/metrics  # Path after /proxy/ is metrics path of pod
      - action: labelmap
        regex: __meta_kubernetes_pod_label_(service|tier|type)
      - source_labels: [__meta_kubernetes_namespace]
        action: replace
        target_label: namespace
      - source_labels: [__meta_kubernetes_pod_name]
        action: replace
        target_label: pod_name
    ...
</code></pre>

<p>With this, we can expose metrics on each individual <code>natsd-*</code> pod <em>within</em> the Kubernetes cluster, without needing to worry about setting up an Ingress nor a Service for the sole purpose of allowing an off-cluster Prometheus setup to access said metrics.</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://ruiwen.github.io/2016/10/30/kubernetes-for-small-organisations/">
        Kubernetes for small Organisations
      </a>
    </h1>

    <span class="post-date">Sun, Oct 30, 2016</span>

    

<h1 id="kubernetes-for-small-organisations-is-it-worth-it">Kubernetes for small Organisations: Is it worth it?</h1>


<div style="position: relative; padding-bottom: 56.25%; padding-top: 30px; height: 0; overflow: hidden;">
  <iframe src="//www.youtube.com/embed/zjVcUg1JTBk" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;" allowfullscreen frameborder="0" title="YouTube Video"></iframe>
 </div>


<p>I recently gave a talk at GeekcampSG 2016 about our ongoing experience with Kubernetes in Lomotif.</p>

<p>It wasn&rsquo;t a technical deep-dive, so I didn&rsquo;t talk very much about the implementation itself, but more about the experience in general, and the pitfalls that we came across. Hopefully, if you&rsquo;re planning a move to Kubernetes, this talk could give you a heads up of a couple of gotchas that you&rsquo;ll probably want to pay attention to before jumping in.</p>

<p>Also great thanks and a shout-out to the wonderful folk from <a href="https://engineers.sg">Engineers.SG</a> who recorded and uploaded the talks from GeekcampSG! =)</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://ruiwen.github.io/2016/10/03/ubuntu-16.04-on-raspberry-pi-3/">
        Ubuntu 16.04 on Raspberry Pi 3
      </a>
    </h1>

    <span class="post-date">Mon, Oct 3, 2016</span>

    

<p>I recently wanted to unify my dev environments, including my (very handy!) Raspberry Pi 3.</p>

<p>I&rsquo;d gotten started with it with a <a href="https://www.raspberrypi.org/downloads/raspbian/">Raspbian Jessie</a>, but felt the new <a href="https://ubuntu-pi-flavour-maker.org/xenial/ubuntu-minimal-16.04-server-armhf-raspberry-pi.img.xz.torrent">Ubuntu 16.04</a> was really more my speed. Thus began the journey to upgrade Pi OSes</p>

<h1 id="images">Images</h1>

<p>First up, finding the right image. The good thing about the Pi community is that there&rsquo;s so much activity, and so many community images. The bad thing is, well, that there are so many community images that it&rsquo;s sometimes hard to tell which is going to work.</p>

<p>Let me save you the trouble — <a href="https://ubuntu-pi-flavour-maker.org/xenial/ubuntu-minimal-16.04-server-armhf-raspberry-pi.img.xz.torrent">this one does</a></p>

<p>It&rsquo;s a link to a <code>.torrent</code> file from <a href="https://ubuntu-pi-flavour-maker.org/">Ubuntu Pi Flavour Maker</a>. You&rsquo;ll end up with a <code>.img.xz</code> file which you&rsquo;ll have to unpack (depending on your OS) to get the original <code>.img</code> image.</p>

<p>After which, it&rsquo;s a quick write to the prepared SD Card (I suggest formatting the card via your OS&rsquo;s disk management tools, so you&rsquo;ll want to back anything important up) with something similar to</p>

<pre><code>sudo dd bs=1m if=path_of_your_image.img of=/dev/diskn
</code></pre>

<p>(The official raspberrypi.org has <a href="https://www.raspberrypi.org/documentation/installation/installing-images/README.md">handy documentation on how you can write a Raspberry Pi <code>.img</code> to your SD card</a>.)</p>

<h1 id="booting-up">Booting Up</h1>

<p>Once you&rsquo;re done writing the image to your SD card, pop it into your Pi, connect the peripherals, plug in the power, and&hellip; <em>wait</em>.</p>

<p>At this stage, unless you have a configured ethernet connection all set up for your Pi and are confident of SSH&rsquo;ing in, you&rsquo;ll probably want a monitor and keyboard attached as well so you can work directly on the console after it boots.</p>

<p>If you don&rsquo;t have a ready ethernet connection, keep in mind that there&rsquo;s a script that waits for an address to be assigned to <code>eth0</code> via DHCP, and times out only after 5 mins. If your Pi isn&rsquo;t responsive after plugging the power in, grab a coffee or something.</p>

<p>After a while, your Pi should be running, and if you&rsquo;ve got a monitor connected to it, you should have a login prompt ready to go.</p>

<p><em>Just in case — the default username and password for RPi Ubuntu images is usually: <code>ubuntu</code> / <code>ubuntu</code></em></p>

<h1 id="connecting-to-wifi">Connecting to Wifi</h1>

<p>The next thing you&rsquo;ll want to do is probably to connect your Pi to your wifi network. If you don&rsquo;t, and already have an ethernet connection good to go, then feel free to skip the rest of this section.</p>

<p>Wireless connections on the RPi are handled by a package called <code>wpasupplicant</code>. It&rsquo;s not installed by default, so you&rsquo;ll need to grab it with a familiar <code>apt-get install</code>. This is also why you need an ethernet connection to at least get started.</p>

<p><em>Pro-tip: If your router/switch is too far away from where you have the rest of your RPi set up, bridging your desktop/laptop&rsquo;s wifi connection over an adapter to an ethernet connection is something I found really handy.</em></p>

<p>You&rsquo;ll also notice that if you entered <code>ifconfig</code> at the prompt, the wireless interface <code>wlan0</code> (by default) has not automatically come up on boot, so we&rsquo;ll need to configure it to do so.</p>

<p>Find and edit the file <code>/etc/network/interfaces</code></p>

<pre><code>$ sudo vim /etc/network/interfaces
</code></pre>

<p>Then add a block to configure the <code>wlan0</code> interface with the requisite wifi credentials</p>

<pre><code>auto wlan0
allow-hotplug wlan0
iface wlan0 inet dhcp
wpa-ssid &quot;YourWifiSSIDHere&quot;
wpa-psk &quot;y0uRs3cretw1f1p@55w0rdHere&quot;
</code></pre>

<p>Save the file, and you should be able to restart the networking service with <code>sudo service networking restart</code> and have the <code>wlan0</code> interface come up.</p>

<pre><code>wlan0     Link encap:Ethernet  HWaddr b8:27:eb:49:2d:dc
          inet addr:192.168.5.103  Bcast:192.168.5.255  Mask:255.255.255.0
          inet6 addr: fe80::bf27:ebdf:fd41:369c/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:165550 errors:0 dropped:4 overruns:0 frame:0
          TX packets:125635 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:131148832 (131.1 MB)  TX bytes:26205017 (26.2 MB)
</code></pre>

<p>Ensure that the interface is properly connected by looking out for the <code>inet addr: 192.168.5.103</code> line. This means that the RPi is connected and has successfully obtained an IP address on that interface.</p>

<p>To be extra certain, you might want to disconnect the ethernet connection at this stage and reboot the RPi and see if it comes up. Remember the IP address that was issued to <code>wlan0</code> here, and use that to try to reconnect to the RPi after it reboots. Most routers will issue the same IP via DHCP to the same host if there is no contention, and on a home/small office network, this usually isn&rsquo;t a problem. This Ubuntu image comes with OpenSSH installed and running, so you&rsquo;ll just need to attempt to connect via SSH once it boots. <em>Keep in mind that even though the ethernet cable has been disconnected, the script that waits for the ethernet interface to come up still times out at 5 minutes, so you have at least that long to wait.</em></p>

<p>With that running, you&rsquo;re good to go!</p>

<h1 id="resizing-the-partition">Resizing the partition</h1>

<p>Once your network is up and running rejoice! Until you run a <code>df -h</code> or similar and realise that your partition seems a lot smaller that you thought it&rsquo;d be.</p>

<p>I&rsquo;m running my Pi off a 64GB microSD card, but when I first looked, <code>df</code> was showing me only a <em>3GB</em> drive thereabouts. Talk about a shock!</p>

<p>A quick google revealed that the Ubuntu image didn&rsquo;t eat up the rest of my 60GB though. Turns out that RPi image is based off of a 4GB disk image, and when I <code>dd</code>ed that over to my sdcard, it just wrote the exact same partition table as well.</p>

<p>Not to fear though, the <a href="http://ubuntu-mate.org/raspberry-pi/">Ubuntu MATE guys have a good writeup on how to resize your RPi&rsquo;s partitions</a> <em>(Search for &ldquo;Re-size file system&rdquo;)</em></p>

<p>In summary though, when you need to do is to delete the smaller ~4GB partition, and rewrite a larger version back to the partition table.</p>

<p>The mounted sdcard is recognised in the RPi usually as <code>/dev/mmcblk0</code>, with the <code>/boot</code> partition on <code>/dev/mmcblk0p1</code> and <code>/dev/mmcblk0p2</code>. We&rsquo;ll need to use <code>fdisk</code> to delete the partition on <code>/dev/mmcblk0p2</code>, and rewrite it back as a larger one.</p>

<pre><code>$ sudo fdisk /dev/mmcblk0
</code></pre>

<p>This gets you into <code>fdisk</code>, where you can then <code>p</code>rint the partition table, and <code>d</code>elete partition <code>2</code>.</p>

<p>Then, create a <code>n</code>ew <code>p</code>rimary partition, accepting the defaults <code>fdisk</code> offers, which would be to use all the remaining space on the sdcard. Remember to <code>w</code>rite the changes to disk before quitting <code>fdisk</code>, otherwise your changes would not take effect.</p>

<p>Once that&rsquo;s done, reboot the system.</p>

<p>You&rsquo;ll notice if you run <code>df -h</code> again once the Pi has booted, that it still says your data is sitting on a smaller ~4GB partition. <em>What gives?</em></p>

<p>Turns out that even though your partition has been resized, the <em>filesystem</em> itself needs to be made aware of its comfy new environment and spread out accordingly.</p>

<p>With a simple</p>

<pre><code>$ resize2fs /dev/mmcblk0p2
</code></pre>

<p>the filesystem is resized, and <code>df -h</code> should finally show you the values you&rsquo;ve been expecting all along.</p>

<h1 id="conclusion">Conclusion</h1>

<p>Once all this is done, your RPi should be up and ready to use! Happy hacking!</p>

  </div>
  
</div>
</div>

  </body>
</html>
